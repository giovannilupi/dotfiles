# -----------------------------------------------------------
# Settings
# -----------------------------------------------------------

# Basic settings
set previewer ~/.config/lf/preview
set sixel true
#set preview true
set icons true
set hidden true
set ignorecase true
set autoquit true
set mouse true
set scrolloff 10
set cursorpreviewfmt "\033[7;2m"
# Shell settings
set shell zsh
set shellopts '-euy'
set ifs "\n"
set filesep "\n"  # default already

# -----------------------------------------------------------
# Command definitions
# -----------------------------------------------------------

# The prefix shows what kind of command it is
#   $: runs as shell command
#   %: runs as piped shell command (stdout => statusline)
#   !: runs as interactive shell command (puts lf in the bg)
#   :: runs as lf command

# define a custom 'open' command
# This command is called when current file is not a directory. You may want to
# use either file extensions and/or mime types here. Below uses an editor for
# text files and a file opener for the rest.
cmd open &{{
    case $(file --mime-type -Lb $f) in
        text/*) lf -remote "send $id \$$EDITOR \$fx";;
        *) for f in $fx; do $OPENER $f > /dev/null 2> /dev/null & done;;
    esac
}}

# Create new directories
cmd newdir %{{
    printf "Enter new directory name(s): "
    # Store new dir names in array
    { IFS=' '; read -r -A names; }
    if [[ -z "${names[1]}" ]]; then printf "\033[48;5;196;38;5;15m[1] no directory names provided\033[0m\n"; return; fi
    # Storage for success and failure
    successful=()
    failed=()
    error_file=$(mktemp)
    # Create dirs
    for dir in "${names[@]}"; do
        if mkdir "$dir" 2>"$error_file"; then 
            successful+=("$dir")
        else 
            err_msg=$(<"$error_file")
            failed+=("$dir")
        fi
    done
    rm -f "$error_file"
    # Print outcome
    if [[ ${#failed[@]} -eq 0 ]]; then
        [[ ${#successful[@]} -gt 1 ]] && \
            printf "\033[48;5;34;38;5;15m[%d] all directories created\033[0m\n" "${#successful[@]}" || \
            printf "\033[48;5;34;38;5;15m[1] directory %s created\033[0m\n" "${successful[1]}"
    elif [[ ${#failed[@]} -eq 1 ]]; then
        printf "\033[48;5;196;38;5;15m[1] directory %s could not be created - %s\033[0m\n" "${failed[1]}" "$(echo "$err_msg" | awk -F ': ' '{print tolower($NF)}')"
    else
        IFS=',' result="${failed[*]//,/, }"
        printf "\033[48;5;196;38;5;15m[%d] some directories could not be created - %s\033[0m\n" "${#failed[@]}" "$result"
    fi
}}

# Create new files
cmd newfile %{{
    printf "Enter new file name(s): "
    # Store new file names in array
    { IFS=' '; read -r -A names; }
    if [[ -z "${names[1]}" ]]; then printf "\033[48;5;196;38;5;15m[1] no file names provided\033[0m\n"; return; fi
    # Storage for success and failure
    successful=()
    failed=()
    error_file=$(mktemp)
    # Create files
    for nf in "${names[@]}"; do
        if [ -e $nf ]; then
            err_msg="already exists"
            failed+=("$nf")
        elif touch "$nf" 2>"$error_file"; then 
            successful+=("$nf")
        else
            err_msg=$(<"$error_file")
            failed+=("$nf")
        fi
    done
    rm -f "$error_file"
    # Print outcome
    if [[ ${#failed[@]} -eq 0 ]]; then
        [[ ${#successful[@]} -gt 1 ]] && \
            printf "\033[48;5;34;38;5;15m[%d] all files created\033[0m\n" "${#successful[@]}" || \
            printf "\033[48;5;34;38;5;15m[1] file %s created\033[0m\n" "${successful[1]}"
    elif [[ ${#failed[@]} -eq 1 ]]; then
        printf "\033[48;5;196;38;5;15m[1] file %s could not be created - %s\033[0m\n" "${failed[1]}" "$(echo "$err_msg" | awk -F ': ' '{print tolower($NF)}')"
    else
        IFS=',' result="${failed[*]//,/, }"
        printf "\033[48;5;196;38;5;15m[%d] some files could not be created - %s\033[0m\n" "${#failed[@]}" "$result"
    fi
}}

# Download file with wget
cmd download %{{
    printf "Enter download link(s): "
    # Store new file names in array
    { IFS=' '; read -r -A links; }
    if [[ -z "${links[1]}" ]]; then printf "\033[48;5;196;38;5;15m[1] no links provided\033[0m\n"; return; fi
    printf "Downloading...\n"
    # Storage for success and failure
    successful=()
    failed=()
    error_file=$(mktemp)
    # Create dirs
    for l in "${links[@]}"; do
        if wget "$l" 2>"$error_file"; then 
            successful+=("$l")
        else
            err_msg=$(<"$error_file")
            failed+=("$l")
        fi
    done
    rm -f "$error_file"
    # Print outcome
    if [[ ${#failed[@]} -eq 0 ]]; then
        [[ ${#successful[@]} -gt 1 ]] && \
            printf "\033[48;5;34;38;5;15m[%d] all files downloaded\033[0m\n" "${#successful[@]}" || \
            printf "\033[48;5;34;38;5;15m[1] file %s downloaded\033[0m\n" "$(basename "${successful[1]}")"
    elif [[ ${#failed[@]} -eq 1 ]]; then
        printf "\033[48;5;196;38;5;15m[1] file %s could not be downloaded - %s\033[0m\n" "$(basename "${successful[1]}")" "$(echo "$err_msg" | tail -n 1 | awk -F ': ' '{print tolower($NF)}')"
    else
        result=$(IFS=','; echo "${failed[@]}" | xargs -n1 basename | paste -sd "," - | sed 's/,/, /g')
        printf "\033[48;5;196;38;5;15m[%d] some files could not be downloaded - %s\033[0m\n" "${#failed[@]}" "$result"
    fi
}}

# Git clone
cmd clone %{{
    printf "Enter link to clone: "
    read -r ans
    if [ -z "$ans" ]; then
        printf "\033[48;5;196;38;5;15m[1] no link provided\033[0m\n"
        return
    fi
    printf "Cloning repository...\n"
    error_file=$(mktemp)
    if git clone "$ans" 2>"$error_file"; then
        printf "\033[48;5;34;38;5;15m[1] repository cloned\033[0m\n"
    else
        printf "\033[48;5;196;38;5;15m[1] failed to clone repository - %s\033[0m\n" "$(awk -F ': ' '{print tolower($NF)}' "$error_file")"
    fi
    rm -f "$error_file"
}}

# Trash command with confirmation
cmd trash %{{
    printf "Move all selected items to trash? [y/n]: "
    read -r ans
    case "$ans" in
        [Yy]*)
            successful=()
            failed=()
            error_file=$(mktemp)
            for f in $fx; do
                if gio trash "$f" 2>"$error_file"; then 
                    successful+=("$f")
                else
                    err_msg=$(<"$error_file")
                    failed+=("$f")
                fi
            done
            rm -f "$error_file"
            if [[ ${#failed[@]} -eq 0 ]]; then
                printf "\033[48;5;34;38;5;15m[%d] all selected items moved to trash\033[0m\n" "${#successful[@]}"
            elif [[ ${#failed[@]} -eq 1 ]]; then
                printf "\033[48;5;196;38;5;15m[1] %s - %s\n" "$(basename "${failed[1]}")" "$(echo "$err_msg" | awk -F ': ' '{print tolower($NF)}')"
            else
                for i in {1..$#failed}; do failed[$i]="$(basename "${failed[$i]}")"; done
                IFS=',' result="${failed[*]//,/, }"
                printf "\033[48;5;196;38;5;15m[%d] some items could not be trashed - %s\033[0m\n" "${#failed[@]}" "$result"
            fi
            ;;
        [Nn]*) printf "\033[48;5;196;38;5;15m[1] operation aborted\033[0m\n" ;;
        *) printf "\033[48;5;196;38;5;15m[1] invalid user response\033[0m\n" ;;
    esac
}}

# Delete command with confirmation
cmd delete %{{
    printf "Delete all selected items? [y/n]: "
    read -r ans
    case "$ans" in
        [Yy]*)
            successful=()
            failed=()
            error_file=$(mktemp)
            for f in $fx; do
                if rm -rf "$f" 2>"$error_file"; then 
                    successful+=("$f")
                else
                    err_msg=$(<"$error_file")
                    failed+=("$f")
                fi
            done
            rm -f "$error_file"
            if [[ ${#failed[@]} -eq 0 ]]; then
                printf "\033[48;5;34;38;5;15m[%d] all selected items deleted\033[0m\n" "${#successful[@]}"
            elif [[ ${#failed[@]} -eq 1 ]]; then
                printf "\033[48;5;196;38;5;15m[1] failed to delete %s - %s\033[0m\n" "$(basename "${failed[1]}")" "$(echo "$err_msg" | awk -F ': ' '{print tolower($NF)}')"
            else
                for i in {1..$#failed}; do failed[$i]="$(basename "${failed[$i]}")"; done
                IFS=',' result="${failed[*]//,/, }"
                printf "\033[48;5;196;38;5;15m[%d] some items could not be deleted - %s\033[0m\n" "${#failed[@]}" "$result"
            fi
            ;;
        [Nn]*) printf "\033[48;5;196;38;5;15m[1] operation aborted\033[0m\n" ;;
        *) printf "\033[48;5;196;38;5;15m[1] invalid user response\033[0m\n" ;;
    esac
}}

# Rename file or directory
cmd rename %{{
    printf "Enter new name: "
    read -r ans
    if [ -z "$ans" ]; then
        printf "\033[48;5;196;38;5;15m[1] new name cannot be empty\033[0m\n"
        return
    fi
    # Check if the new filename contains a directory separator
    if [[ "$ans" == *"/"* ]]; then
        printf "\033[48;5;196;38;5;15m[1] new name contains a directory separator\033[0m\n"
        return
    fi
    # Check if a file with the same name already exists
    # This avoids the possibility of moving a file to a directory in the same path
    if [ -e "$ans" ]; then
        if [ -L "$ans" ]; then anstype="symlink"; elif [ -d "$ans" ]; then anstype="directory"; else anstype="file"; fi
        printf "\033[48;5;196;38;5;15m[1] a %s already exists with name %s\033[0m\n" "$anstype" "$ans"
        return
    fi
    # Check $f type
    if [ -L "$f" ]; then ftype="symlink"; elif [ -d "$f" ]; then ftype="directory"; else ftype="file"; fi
    error_file=$(mktemp)
    if mv -f "$f" "$ans" 2>"$error_file"; then
        printf "\033[48;5;34;38;5;15m[1] $ftype %s renamed to %s\033[0m\n" "$(basename "$f")" "$ans"
    else
        printf "\033[48;5;196;38;5;15m[1] $ftype %s could not be renamed - %s\033[0m\n" "$(basename "$f")" "$(awk -F ': ' '{print tolower($NF)}' "$error_file")"
    fi
    rm -f "$error_file"
}}

# Extract the current file with the right command
cmd extract %{{
    set -f
    case $f in
        *.tar.bz|*.tar.bz2|*.tbz|*.tbz2) tar xjvf $f;;
        *.tar.gz|*.tgz) tar xzvf $f;;
        *.tar.xz|*.txz) tar xJvf $f;;
        *.zip) unzip $f;;
        *.rar) unrar x $f;;
        *.7z) 7z x $f;;
    esac
}}

# compress current file or selected files with tar and gunzip
cmd tar ${{
    set -f
    mkdir $1
    cp -r $fx $1
    tar czf $1.tar.gz $1
    rm -rf $1
}}

# compress current file or selected files with zip
cmd zip ${{
    set -f
    mkdir $1
    cp -r $fx $1
    zip -r $1.zip $1
    rm -rf $1
}}
cmd tar2 %tar cvf "$f.tar" "$f"

# Make selected files executable
cmd chmod %{{
    for f in "$fx"; do chmod a+x $f; done
    lf -remote 'send reload'
}}

# Open file or project in VSCode
cmd vscode %{{
    code "$f"
    lf -remote 'send reload'
}}

# Open file in Sublime
cmd sublime %{{
    if [ -f "$f" ]; then
        subl "$f"
        lf -remote 'send reload'
    else
        printf "\033[48;5;196;38;5;15m[1] cannot open a directory with Sublime\033[0m\n"
    fi
}}

# Copy path of the current dir to clipboard
cmd copydirpath %{{
    print -n "$PWD" | pbcopy
    printf "\033[48;5;34;38;5;15m[1] %s copied to clipboard\033[0m\n" "$PWD"    
}}

# Copy path of the selected file to clipboard
cmd copyfilepath %{{
    print -n "$f" | pbcopy
    printf "\033[48;5;34;38;5;15m[1] %s copied to clipboard\033[0m\n" "$f"    
}}

# Open Finder in current dir
cmd openfinder %{{
    open .
    lf -remote 'send reload'
}}

# -----------------------------------------------------------
# Bindings
# -----------------------------------------------------------

# Remove default bindings
map m
map o
map n
map "'"
map '"'
map d
map c
map e
#map f
map w
map d
map r
map v
map s
map f

map y copy
map p paste
map x cut
map i invert
map d clear
map u unselect
map <c-a> glob-select *
map <a-down> half-down
map <a-up> half-up

map <esc> quit
map <enter> shell
map T trash
map D delete
map R rename
map E extract
map nd newdir
map nf newfile
map wg download
map nr tar2
map chm chmod
map vsc vscode
map sbl sublime
map cfp copyfilepath
map cdp copydirpath
map clone clone
map fd openfinder
map . set hidden!

# execute current file (must be executable)
map ex $$f
map eX !$f

# dedicated keys for file opener actions
map o &mimeopen $f
map O $mimeopen --ask $f

# Movement
map gh cd ~
map gd cd ~/Documents
map gp cd ~/Documents/Programming
map gi cd ~/Pictures
map gc cd ~/.config
